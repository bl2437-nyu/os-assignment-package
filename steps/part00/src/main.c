#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <string.h>
#include <inttypes.h>
#include <fcntl.h>

#include <sha2.h>
#include <bitcoin_utils.h>
#include <data_utils.h>
#include <debug_utils.h>

int main(){
    // seed the random number generator
    srand(time(NULL));
    
    int difficulty=DIFFICULTY_1M;
    char target[32];
    construct_target(difficulty, &target);
    
    // create a BitcoinBlock
    BitcoinBlock* genesis=malloc(sizeof(BitcoinBlock));
    initialize_block(genesis, difficulty);
    
    // full the block with data that is identical to the Genesis block
    get_dummy_genesis_block(genesis);
    
    // print the header in human-readable format
    debug_print_header(genesis->header);
    
    
    
    MerkleTreeDataNode* data1=malloc(sizeof(MerkleTreeDataNode));
    MerkleTreeDataNode* data2=malloc(sizeof(MerkleTreeDataNode));
    MerkleTreeDataNode* data3=malloc(sizeof(MerkleTreeDataNode));
    
    // These are the first three transactions of Bitcoin, spread across
    // the first three blocks on the blockchain.
    // Let's pretend we put them together in one block...
    char transaction1[]={
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x4d, 0x04, 0xff, 0xff, 0x00, 0x1d, 0x01,
        0x04, 0x45, 0x54, 0x68, 0x65, 0x20, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x20, 0x30, 0x33, 0x2f, 0x4a,
        0x61, 0x6e, 0x2f, 0x32, 0x30, 0x30, 0x39, 0x20,
        0x43, 0x68, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x6c,
        0x6f, 0x72, 0x20, 0x6f, 0x6e, 0x20, 0x62, 0x72,
        0x69, 0x6e, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x73,
        0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x62, 0x61,
        0x69, 0x6c, 0x6f, 0x75, 0x74, 0x20, 0x66, 0x6f,
        0x72, 0x20, 0x62, 0x61, 0x6e, 0x6b, 0x73, 0xff,
        0xff, 0xff, 0xff, 0x01, 0x00, 0xf2, 0x05, 0x2a,
        0x01, 0x00, 0x00, 0x00, 0x43, 0x41, 0x04, 0x67,
        0x8a, 0xfd, 0xb0, 0xfe, 0x55, 0x48, 0x27, 0x19,
        0x67, 0xf1, 0xa6, 0x71, 0x30, 0xb7, 0x10, 0x5c,
        0xd6, 0xa8, 0x28, 0xe0, 0x39, 0x09, 0xa6, 0x79,
        0x62, 0xe0, 0xea, 0x1f, 0x61, 0xde, 0xb6, 0x49,
        0xf6, 0xbc, 0x3f, 0x4c, 0xef, 0x38, 0xc4, 0xf3,
        0x55, 0x04, 0xe5, 0x1e, 0xc1, 0x12, 0xde, 0x5c,
        0x38, 0x4d, 0xf7, 0xba, 0x0b, 0x8d, 0x57, 0x8a,
        0x4c, 0x70, 0x2b, 0x6b, 0xf1, 0x1d, 0x5f, 0xac,
        0x00, 0x00, 0x00, 0x00
    };
    char transaction2[]={
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x07, 0x04, 0xff, 0xff, 0x00, 0x1d, 0x01,
        0x04, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xf2,
        0x05, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x43, 0x41,
        0x04, 0x96, 0xb5, 0x38, 0xe8, 0x53, 0x51, 0x9c,
        0x72, 0x6a, 0x2c, 0x91, 0xe6, 0x1e, 0xc1, 0x16,
        0x00, 0xae, 0x13, 0x90, 0x81, 0x3a, 0x62, 0x7c,
        0x66, 0xfb, 0x8b, 0xe7, 0x94, 0x7b, 0xe6, 0x3c,
        0x52, 0xda, 0x75, 0x89, 0x37, 0x95, 0x15, 0xd4,
        0xe0, 0xa6, 0x04, 0xf8, 0x14, 0x17, 0x81, 0xe6,
        0x22, 0x94, 0x72, 0x11, 0x66, 0xbf, 0x62, 0x1e,
        0x73, 0xa8, 0x2c, 0xbf, 0x23, 0x42, 0xc8, 0x58,
        0xee, 0xac, 0x00, 0x00, 0x00, 0x00
    };
    char transaction3[]={
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x07, 0x04, 0xff, 0xff, 0x00, 0x1d, 0x01,
        0x0b, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xf2,
        0x05, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x43, 0x41,
        0x04, 0x72, 0x11, 0xa8, 0x24, 0xf5, 0x5b, 0x50,
        0x52, 0x28, 0xe4, 0xc3, 0xd5, 0x19, 0x4c, 0x1f,
        0xcf, 0xaa, 0x15, 0xa4, 0x56, 0xab, 0xdf, 0x37,
        0xf9, 0xb9, 0xd9, 0x7a, 0x40, 0x40, 0xaf, 0xc0,
        0x73, 0xde, 0xe6, 0xc8, 0x90, 0x64, 0x98, 0x4f,
        0x03, 0x38, 0x52, 0x37, 0xd9, 0x21, 0x67, 0xc1,
        0x3e, 0x23, 0x64, 0x46, 0xb4, 0x17, 0xab, 0x79,
        0xa0, 0xfc, 0xae, 0x41, 0x2a, 0xe3, 0x31, 0x6b,
        0x77, 0xac, 0x00, 0x00, 0x00, 0x00
    };
    
    data1->length=204;
    data1->data=transaction1;
    data2->length=134;
    data2->data=transaction2;
    data3->length=134;
    data3->data=transaction3;
    
    // TODO: construct merkle tree.
    // Here's one node for reference.
    // For nodes that represent hash of a transaction, set data to hold the
    // pointer of the data node, and set left and right to NULL.
    // For nodes that represent hash of two child nodes, set left and right
    // to hold the pointer to the hash nodes, and set data to NULL.
    // If there is only one child, set it to left, and set right to NULL.
    // Check `bitcoin_utils.h` for definitions of the data structures.
    MerkleTreeHashNode* node1=malloc(sizeof(MerkleTreeHashNode));
    node1->left=NULL;
    node1->right=NULL;
    node1->data=data1;
    
    
    
    // When you are done, uncomment the block comment below.
    /*
    BitcoinBlock* my_block=malloc(sizeof(BitcoinBlock));
    // TODO: set the root of your merkle tree here
    my_block->merkle_tree=...
    
    update_merkle_root(my_block);
    
    debug_print_hex_line(&(my_block->header.merkle_root), 32);
    // should be:
    // D291F07194FB0FC204EA31C91101EDE34E991C67D285C04B815AFEFEE63CF4EA
    
    // set up the rest of the data in the block header
    my_block->header.version=4;
    memset(&(my_block->header.previous_block_hash), 0, 32);
    my_block->header.timestamp=time(NULL);
    my_block->header.difficulty=difficulty;
    my_block->header.nonce=0;
    */
    
    // TODO: Write a brute force loop, and print a nonce you find.
    // use is_good_block(&(my_block->header), target) to check if the hash
    // is valid.
    
    
    
    // TODO: free() any memory you malloc'd.
    free(genesis);
    free(data1);
    free(data2);
    free(data3);
    free(node1);
    //free(my_block);
    
    
    return 0;
    
}



























